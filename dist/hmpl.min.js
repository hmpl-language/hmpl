!function(e,t){"object"==typeof module&&module.exports?module.exports=t():"function"==typeof define&&define.amd?define([],t):e.hmpl=e.hmpl||t()}("undefined"!=typeof self?self:this,(function(){return function(){"use strict";const e="src",t="method",o="initId",n="after",r="repeat",s="memo",i="indicators",l="autoBody",c="hmpl",d="formData",a="disallowedTags",p="sanitize",f="allowedContentTypes",h="get",u="interval",m="BadResponseError",y="RequestInitError",$="RenderError",g="RequestComponentError",v="CompileOptionsError",b="ParseError",w="CompileError",T={formData:!0},N={formData:!1},O=[e,t,o,n,r,i,s,l,f,a,p,u],P=["get","post","put","delete","patch","trace","options"],E=[100,101,102,103,300,301,302,303,304,305,306,307,308,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,421,422,423,424,425,426,428,429,431,451,500,501,502,503,504,505,506,507,508,510,511],x=["script","style","iframe"],j=["text/html"],k=[],C=e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,I=e=>"[object Function]"===Object.prototype.toString.call(e),A=e=>{throw new Error(e)},q=e=>{console.warn(e)},D=(e,t=!1,o)=>{let n=e;t&&(n=o?DOMPurify.sanitize(e,o):DOMPurify.sanitize(e));return(new DOMParser).parseFromString(`<template>${n}</template>`,"text/html").childNodes[0].childNodes[0].firstChild},S=(e,t,o,n)=>({prop:e,value:t,context:o,request:n}),R=(e,t,o,n,r,s,i,l,c={},d,a,p,f,h,u,$,g)=>{const{mode:v,cache:b,redirect:w,get:T,referrerPolicy:N,signal:O,credentials:P,timeout:E,referrer:x,headers:j,body:k,window:I,integrity:R}=c,M={method:n.toUpperCase()};void 0!==P&&(M.credentials=P),void 0!==k&&(M.body=k),void 0!==v&&(M.mode=v),void 0!==b&&(M.cache=b),void 0!==w&&(M.redirect=w),void 0!==N&&(M.referrerPolicy=N),void 0!==R&&(M.integrity=R),void 0!==x&&(M.referrer=x);const z=void 0!==O;if(z&&(M.signal=O),void 0!==I&&(M.window=I),void 0!==c.keepalive&&q(`${y}: The "keepalive" property is not yet supported`),j)if(C(j)){const e=new Headers;for(const t in j){const o=j[t],n=typeof o;"string"===n?e.set(t,o):A(`${y}: Expected type string, but received type ${n}`)}M.headers=e}else A(`${y}: The "headers" property must contain a value object`);E&&(z?q(`${y}: The "signal" property overwrote the AbortSignal from "timeout"`):M.signal=AbortSignal.timeout(E));const F=l&&!s&&o?.memo,L=e=>"rejected"===e||"number"==typeof e&&(e<200||e>299),W=B(void 0,g),U=e=>{i&&(u.response=e,T?.(S("response",e,W,u))),T?.(S("response",t,W))},H=(t,n=!0,r=!1)=>{if(s)d.response=t.cloneNode(!0),T?.(S("response",t,W));else{let s=[];const i=[...(n?t.cloneNode(!0):t).content.childNodes];if(o.nodes){const e=o.parentNode,t=[],n=o.nodes.length;for(let r=0;r<n;r++){const s=o.nodes[r];if(r===n-1)for(let o=0;o<i.length;o++){const n=i[o],r=e.insertBefore(n,s);t.push(r)}e.removeChild(s)}s=t.slice(),o.nodes=t}else{const t=e.parentNode,n=[],r=i.length;for(let o=0;o<r;o++){const r=i[o],s=t.insertBefore(r,e);n.push(s)}t.removeChild(e),s=n.slice(),o.nodes=n,o.parentNode=t}F&&r&&(o.memo.nodes=o.nodes,o.memo.isPending&&(o.memo.isPending=!1)),U(s)}};let _=!1;const G=()=>{if(s)d.response=void 0,T?.(S("response",void 0,W));else if(o?.nodes){const e=o.parentNode,n=o.nodes.length;for(let t=0;t<n;t++){const r=o.nodes[t];t===n-1&&e.insertBefore(o.comment,r),e.removeChild(r)}o.nodes=null,o.parentNode=null,i&&(u.response=void 0,T?.(S("response",void 0,W,u))),T?.(S("response",t,W))}F&&null!==o.memo.response&&(o.memo.response=null,delete o.memo.isPending,delete o.memo.nodes)},V=e=>{i?u.status!==e&&(u.status=e,T?.(S("status",e,W,u))):d.status!==e&&(d.status=e,T?.(S("status",e,W))),F&&L(e)&&(o.memo.response=null,delete o.memo.nodes),(e=>{if($)if(F&&"pending"!==e&&L(e)&&o.memo.isPending&&(o.memo.isPending=!1),"pending"===e){const e=$.pending;void 0!==e&&(F&&(o.memo.isPending=!0),H(e))}else if("rejected"===e){const e=$.rejected;if(void 0!==e)H(e);else{const e=$.error;void 0!==e?H(e):G()}}else{const t=$[`${e}`];if(e>399)if(void 0!==t)H(t);else{const e=$.error;void 0!==e?H(e):G()}else(e<200||e>299)&&(_=!0,void 0!==t?H(t):G())}})(e)};let J=200;V("pending");let X=!0,Z=!0;fetch(r,M).then((e=>{if(X=!1,J=e.status,V(J),e.ok||($&&(Z=!1),A(`${m}: Response with status code ${J}`)),Array.isArray(a)&&0!==a.length){const t=e.headers.get("Content-Type");((e,t)=>{if(!e)return!0;let o=!1;for(let n=0;n<t.length;n++){const r=t[n];if(e.includes(r)){o=!0;break}}return!o})(t,a)&&A(`${m}: Expected ${a.map((e=>`"${e}"`)).join(", ")}, but received "${t}"`)}return e.text()})).then((n=>{if(!_){if(F){const{response:e}=o.memo;if(null===e)o.memo.response=n;else{if(e===n)return void(()=>{if(o.memo.isPending){const e=o.parentNode,t=o.memo.nodes,n=o.nodes,r=n.length,s=[];for(let o=0;o<r;o++){const i=n[o];if(o===r-1)for(let o=0;o<t.length;o++){const n=t[o],r=e.insertBefore(n,i);s.push(r)}e.removeChild(i)}o.nodes=s.slice(),o.memo.isPending=!1,o.memo.nodes=s.slice()}const e=o.nodes.slice();U(e)})();o.memo.response=n,delete o.memo.nodes}}const r=((e,t=[],o,n)=>{const r=D(e,o,n),s=r.content;for(let e=0;e<t.length;e++){const o=t[e],n=s.querySelectorAll(o);for(let e=0;e<n.length;e++)s.removeChild(n[e])}return r})(n,p,f,h);if(s)d.response=r,T?.(S("response",r,W));else{const n=[],s=[...r.content.childNodes];if(o)H(r,!1,!0);else{const o=e.parentNode;for(let t=0;t<s.length;t++){const r=s[t],l=o.insertBefore(r,e);i&&n.push(l)}o.removeChild(e),i&&(u.response=n,T?.(S("response",n,W,u))),T?.(S("response",t,W))}}}})).catch((e=>{throw X?(V("rejected"),$||G()):Z&&G(),e}))},B=(e,t)=>{const o={};return void 0!==e&&(o.event=e),t&&(o.clearInterval=t),{request:o}},M=(i,d,h,m,v,w,O,x,q,S=!1)=>{const M=(i,c)=>{const d=i[e];if(d){const e=(i[t]||"GET").toLowerCase();if((e=>P.includes(e.toLowerCase()))(e)){const t=i[n];t&&S&&A(`${$}: EventTarget is undefined`);const h=!i.hasOwnProperty(r),b="all"===(!!h||i[r]?"all":"one"),P=i[u],M=!i.hasOwnProperty(s),U=!i.hasOwnProperty(u),_=m.sanitizeConfig;let G=!v&&m[s];M?G&&(t&&b||(G=!1)):t?i[s]?b?G=!0:A(`${g}: Memoization works in the enabled repetition mode`):G=!1:A(`${g}: Memoization works in the enabled repetition mode`),U||b&&t&&A(`${g}: The "${u}" property does not work with repetiton mode yet`);const V=!i.hasOwnProperty(l);let J=!w&&m[l];if(V)!0===J&&(J=T),t||(J=!1);else if(t){let e=i[l];if(F(e),!0===J&&(J=T),!0===e&&(e=T),!1===e)J=!1;else{const t={...!1===J?N:J,...e};J=t}}else J=!1,A(`${g}: The "${l}" property does not work without the "${n}" property`);const X=!i.hasOwnProperty(f);let Z=O?j:m[f];if(!X){const e=i[f];z(e),Z=e}const K=!i.hasOwnProperty(a);let Q=x?k:m[a];if(!K){const e=i[a];L(e),Q=e}const Y=!i.hasOwnProperty(p);let ee=!q&&m[p];if(!Y){const e=i[p];W(e),ee=e}const te=i[o],oe=i.nodeId;let ne=i.indicators;if(ne){const e=e=>{const{trigger:t,content:o}=e;t||A(`${g}: Failed to activate or detect the indicator`),o||A(`${g}: Failed to activate or detect the indicator`),-1===E.indexOf(t)&&"pending"!==t&&"rejected"!==t&&"error"!==t&&A(`${g}: Failed to activate or detect the indicator`);const n=D(o);return{...e,content:n}},t={},o=[];for(let n=0;n<ne.length;n++){const r=e(ne[n]),{trigger:s}=r;-1===o.indexOf(s)?o.push(s):A(`${g}: Indicator trigger must be unique`),t[`${s}`]=r.content}ne=t}const re=(e,t=!1)=>{if(t){if(te){let t;for(let o=0;o<e.length;o++){const n=e[o];if(n.id===te){t=n.value;break}}return t||A(`${g}: ID referenced by request not found`),t}return{}}return te&&A(`${g}: ID referenced by request not found`),e},se=void 0!==P,ie=b&&t||se,le=(t,o,n,r,s,i=!1,l,a=!1,p,f,h)=>{const u=r.currentId;if(S)t||(t=c);else if(!t){let e;const{els:o}=r;for(let t=0;t<o.length;t++){const n=o[t];if(n.id===oe){p=n,e=n.el;break}}t=e}let m;S||(ie||ne)&&(m=p.objNode,m||(m={id:u,nodes:null,parentNode:null,comment:t},G&&(m.memo={response:null},ne&&(m.memo.isPending=!1)),se&&h&&(m.interval={value:h,clearInterval:()=>clearInterval(h)}),p.objNode=m,r.dataObjects.push(m),r.currentId++));let $=re(o,i);const g=I($);if(!g&&$&&($={...$}),J&&J.formData&&f&&!g){const{type:e,target:t}=f;"submit"===e&&t&&t instanceof HTMLFormElement&&"FORM"===t.nodeName&&($.body=new FormData(t,f.submitter))}let v=h?()=>clearInterval(h):void 0;v=S?v:m?.interval?.clearInterval;const b=g?((e,t,o)=>e(B(t,o)))($,f,v):$;C(b)||void 0===b||A(`${y}: Expected an object with initialization options`),R(t,s,m,e,d,S,a,G,b,n,Z,Q,ee,_,l,ne,v)};let ce=le;if(P){H(P);const e=Number(P);ce=(t,o,n,r,s,i=!1,l,c=!1,d,a)=>{let p=null;p=setInterval((()=>{le(t,o,n,r,s,i,l,c,d,a,p)}),e)}}let de=ce;if(t){const e=(e,t,o,n,r,s,i,l,c,d,a)=>{const p=c.querySelectorAll(o);0===p.length&&A(`${$}: Selectors nodes not found`);const f=b?t=>{ce(e,n,r,s,c,i,d,l,a,t)}:o=>{ce(e,n,r,s,c,i,d,l,a,o);for(let e=0;e<p.length;e++){p[e].removeEventListener(t,f)}};for(let e=0;e<p.length;e++){p[e].addEventListener(t,f)}};if(t.indexOf(":")>0){const o=t.split(":"),n=o[0],r=o.slice(1).join(":");de=(t,o,s,i,l,c=!1,d,a=!1,p)=>{e(t,n,r,o,s,i,c,a,l,d,p)}}else A(`${g}: The "${n}" property doesn't work without EventTargets`)}else h||A(`${g}: The "${r}" property doesn't work without "${n}" property`);return de}A(`${g}: The "${t}" property has only GET, POST, PUT, PATCH, TRACE, OPTIONS or DELETE values`)}else A(`${g}: The "${e}" property are not found or empty`)};let U;if(S)h[0].el=i,U=M(h[0]);else{let e=-2;const t=o=>{if(e++,8==o.nodeType){let t=o.nodeValue;if(t&&t.startsWith(c)){t=t.slice(4);const n=Number(t),r=h[n];(Number.isNaN(n)||void 0===r)&&A(`${b}: Block helper with id "${n}" not found`),r.el=o,r.nodeId=e}}if(o.hasChildNodes()){const e=o.childNodes;for(let o=0;o<e.length;o++)t(e[o])}};if(t(i),h.length>1){const e=[];for(let t=0;t<h.length;t++){const o=h[t];e.push(M(o,i))}U=(t,o,n,r,s,i=!1)=>{t||(t=s);const l=[],c=r.els;for(let s=0;s<c.length;s++){const d=c[s],a=d.el,p={response:void 0};(0,e[s])(a,o,n,r,t,i,p,!0,d),l.push(p)}n.requests=l}}else{U=M(h[0],i)}}return d(U)},z=(e,t=!1)=>{const o=t?v:g;"*"===e||((e,t)=>{if(!Array.isArray(e))return!1;let o=!0;for(let n=0;n<e.length;n++)if("string"!=typeof e[n]){A(`${t}: In the array, the element with index ${n} is not a string`),o=!1;break}return o})(e,o)||A(`${o}: Expected "*" or string array, but got neither`)},F=(e,t=!1)=>{const o=C(e),n=t?v:g;if("boolean"==typeof e||o||A(`${n}: Expected a boolean or object, but got neither`),o)for(const t in e)if(t===d)"boolean"!=typeof e[d]&&A(`${n}: The "${d}" property should be a boolean`);else A(`${n}: Unexpected property "${t}"`)},L=(e,t=!1)=>{const o=t?v:g;Array.isArray(e)||A(`${o}: The value of the property "${a}" must be an array`);for(let t=0;t<e.length;t++){const n=e[t];x.includes(n)||A(`${o}: The value "${n}" is not processed`)}},W=(e,t=!1)=>{"boolean"!=typeof e&&A(`${t?v:g}: The value of the property "${p}" must be a boolean`)},U=e=>{e.hasOwnProperty("id")&&e.hasOwnProperty("value")||A(`${y}: Missing "id" or "value" property`)},H=e=>{"number"!=typeof e&&A(`${g}: The "${u}" value must be number`)};return{compile:(e,t={})=>{"string"!=typeof e&&A(`${w}: Template was not found or the type of the passed value is not string`),e||A(`${w}: Template must not be a falsey value`),C(t)||A(`${v}: Options must be an object`);const n=!t.hasOwnProperty(s);n||"boolean"==typeof t[s]||A(`${v}: The value of the property ${s} must be a boolean`);const d=!t.hasOwnProperty(l);d||F(t[l],!0);const m=!t.hasOwnProperty(f);m||z(t[f],!0);const T=!t.hasOwnProperty(a);T||L(t[a],!0);const N=!t.hasOwnProperty(p);N||W(t[p],!0);const P=[],E=[],x=e=>{let t="";const o=/\s*([a-zA-Z0-9_-]+)\s*=\s*(("[^"]*"|'[^']*'|`[^`]*`|\[[^\]]*\]|\{[^}]*\}|true|false|\d+)(?=\s|,|$))\s*/g;let n;for(;null!==(n=o.exec(e));){t+=`${n[1].trim()}:${n[2].trim()},`}return t.replace(/,$/,"").trim()},j=(e=>{const t=[];let o=0;const n=[{open:"{{#request",close:"{{/request}}"},{open:"{{#r",close:"{{/r}}"}];for(;o<e.length;){const r=n.map((t=>({...t,index:e.indexOf(t.open,o)}))).filter((e=>-1!==e.index));if(0===r.length){t.push(e.slice(o));break}const s=r.sort(((e,t)=>e.index-t.index))[0];t.push(e.slice(o,s.index));const i=s.index+s.open.length,l=e.indexOf("}}",i);-1===l&&A(`${b}: Unclosed block (no ending '}}') for ${s.open}`);const c=e.slice(i,l).trim(),d=e.indexOf(s.close,l);-1===d&&A(`${b}: No closing '${s.close}' found for ${s.open}}}`);const a=e.slice(l+2,d);a.includes(s.open)&&A(`${b}: Nested ${s.open}}} blocks are not supported`);const p=x(c);if(s.open.startsWith(n[0].open)||s.open.startsWith(n[1].open)){const e=[],o=/{{#indicator\s+([^}]*)}}([\s\S]*?){{\/indicator}}/g;let n;for(;null!==(n=o.exec(a));){const t=n[1].trim();let o=n[2].trim();const r="{{#indicator";o.includes(r)&&A(`${b}: Nested ${r}}} blocks are not supported`);const s=x(t);o=o.replace(/\n/g," ").replace(/\s+/g," ").trim();const i=o.replace(/\\/g,"\\\\").replace(/`/g,"\\`").replace(/\$/g,"\\$");e.push(`{${s}, content:'${i}'}`)}const r=e.length>0?`,indicators:[${e.join(",")}]`:"";t.push(`{${p}${r}}`)}E.push(t.length-1),o=d+s.close.length}return t})(e);0===E.length&&A(`${b}: Block helper not found`);const k=e=>{const t=JSON5.parse(e);for(const e in t){const n=t[e];switch(O.includes(e)||A(`${g}: Property "${e}" is not processed`),e){case i:Array.isArray(n)||A(`${g}: The value of the property "${e}" must be an array`);break;case o:"string"!=typeof n&&"number"!=typeof n&&A(`${g}: The value of the property "${e}" must be a string`);break;case s:case r:"boolean"!=typeof n&&A(`${g}: The value of the property "${e}" must be a boolean value`);break;case l:F(n);break;case f:z(n);break;case a:L(n);break;case p:W(n);break;case u:H(n);break;default:"string"!=typeof n&&A(`${g}: The value of the property "${e}" must be a string`)}}const n={...t};P.push(n)};for(let e=0;e<E.length;e++){const t=E[e];k(j[t]);const o=`\x3c!--hmpl${e}--\x3e`;j[t]=o}e=j.join("");let q=!1;const S=(e=>{const t=D(e.trim());(t.content.childNodes.length>1||1!==t.content.children.length&&8!==t.content.childNodes[0].nodeType)&&A(`${$}: Template includes only one node of the Element type or one response object`);const o=e=>{switch(e.nodeType){case Node.ELEMENT_NODE:if("PRE"===e.tagName)return;break;case Node.TEXT_NODE:if(!/\S/.test(e.textContent))return void e.remove()}for(let t=0;t<e.childNodes.length;t++)o(e.childNodes.item(t))};o(t.content.childNodes[0]);let n=t.content.firstElementChild;if(!n){const e=t.content.firstChild;8===e?.nodeType&&(q=!0,n=e)}return n})(e);return M(S,(e=>(t={})=>{const o=S.cloneNode(!0),n={response:q?void 0:o},r={dataObjects:[],els:[],currentId:0};if(!q){let e=-2;const t=o=>{if(e++,8==o.nodeType){const t=o.nodeValue;if(t&&t.startsWith(c)){const t={el:o,id:e};r.els.push(t)}}if(o.hasChildNodes()){const e=o.childNodes;for(let o=0;o<e.length;o++)t(e[o])}};t(o)}var s;return C(t)||I(t)?(C(s=t)&&s.hasOwnProperty(`${h}`)&&(I(s[h])||A(`${y}: The "${h}" property has a function value`)),e(void 0,t,n,r,o)):Array.isArray(t)?((e=>{const t=[];for(let o=0;o<e.length;o++){const n=e[o];C(n)||A(`${y}: IdentificationRequestInit is of type object`),U(n);const{id:r}=n,s="string"==typeof n.id;s||"number"==typeof n.id||A(`${y}: ID must be a string or a number`),t.indexOf(r)>-1?A(`${y}: ID with value ${s?`"${r}"`:r} already exists`):t.push(r)}})(t),e(void 0,t,n,r,o,!0)):A(`${y}: The type of the value being passed does not match the supported types for RequestInit`),n}),P,t,n,d,m,T,N,q)},stringify:e=>{const t=e=>"string"==typeof e?`"${e}"`:"number"==typeof e||"boolean"==typeof e?`${e}`:Array.isArray(e)?`[${e.map((e=>t(e))).join(",")}]`:"object"==typeof e&&null!==e?`{${Object.entries(e).map((([e,o])=>`${e}:${t(o)}`)).join(",")}}`:"";let o=Object.entries(e).map((([e,o])=>`${e}=${t(o)}`)).join(" ");return o.endsWith("}")&&(o+=" "),`{{#request ${o}}}{{/request}}`}}}()}));